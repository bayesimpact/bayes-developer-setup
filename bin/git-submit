#!/bin/bash
#
# A git custom command to submit a reviewed branch.
# Usage:
#   git submit [<branch>]
#   Submits the given or the current branch.
#
# It ensures that the modifications of the branch are rebased on the remote
# default branch as exactly one commit. It also cleans up the branch locally and
# remotely.
#
# To install it, copy it or link it from /usr/local/bin/git-submit and gzip the
# manpage to /usr/local/man/man1.

# Find the branch to submit.
if [ "$1" == "-f" ] || [ "$1" == "--force" ]; then
  BRANCH="$2"
  FORCE_SUBMIT="$1"
else
  BRANCH="$1"
  FORCE_SUBMIT="$2"
fi

# The name of the remote used for default distant branch, usually "origin".
readonly BASE_REMOTE_MAIN="$(git config branch.main.remote)"
readonly BASE_REMOTE_MASTER="$(git config branch.master.remote)"
if [ "${BASE_REMOTE_MAIN}" != "" ]; then
  readonly BASE_REMOTE=${BASE_REMOTE_MAIN}
elif [ "${BASE_REMOTE_MASTER}" != "" ]; then
  readonly BASE_REMOTE=${BASE_REMOTE_MASTER}
else
  readonly BASE_REMOTE="origin"
fi

# Get GitHub repo user.
# The remote URL is "git@github.com:bayesimpact/new-project.git" and we want
# to extract "bayesimpact" and "new-project".
if [[ "$(git remote get-url "${BASE_REMOTE}")" =~ ^git@github.com:(.*)/(.*).git$ ]]; then
  readonly GITHUB_REPO_USER="${BASH_REMATCH[1]}"
fi

# Compute DEFAULT_REMOTE_BRANCH which is usually main (and previously master).
# No readonly because it prevents from getting the rev-parse exit code.
ORIGIN_DEFAULT="$(git rev-parse --abbrev-ref "${BASE_REMOTE}/HEAD" 2> /dev/null)"
if [ $? -ne 0 ]; then
  if [ -z "${GITHUB_REPO_USER}" ]; then
    readonly DEFAULT_REMOTE_BRANCH="$(hub api repos/{owner}/{repo} | jq -r .default_branch)"
  else # Default case: main is the default branch.
    readonly DEFAULT_REMOTE_BRANCH="main"
  fi
else
  readonly DEFAULT_REMOTE_BRANCH="$(cut -d/ -f2 <<< "${ORIGIN_DEFAULT}")"
fi

function get_default_branch {
  for branch in $(git for-each-ref --format='%(refname:short)' refs/heads); do
    if [ "$(git rev-parse --abbrev-ref $branch@{upstream} 2> /dev/null)" == "${BASE_REMOTE}/${DEFAULT_REMOTE_BRANCH}" ]; then
      echo $branch
    fi
  done
}
# Compute DEFAULT_BRANCH which is usually main (and previously master).
readonly DEFAULT_BRANCH=$(get_default_branch)

if [ -z "${BRANCH}" ]; then
  BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  if [ "${BRANCH}" == "${DEFAULT_BRANCH}" ]; then
    echo "branch required:" 1>&2
    git branch | grep -v \ $DEFAULT_BRANCH$ 1>&2
    exit 1
  fi
fi

# Disable specific option if user has the experimental NO_GIT_SUBMIT_EXPERIMENTAL env var set.
readonly NO_SQUASH_ON_GITHUB="${NO_GIT_SUBMIT_EXPERIMENTAL}"

# Ensures that current dir is clean.
if [ -n "$(git diff HEAD --shortstat 2> /dev/null | tail -n1)" ]; then
  echo "Current git status is dirty. Commit, stash or revert your changes before submitting." 1>&2
  exit 2
fi

if ! git rev-parse --verify "${BRANCH}" 2>&1 > /dev/null; then
  echo "${BRANCH} is not a valid branch." 1>&2
  exit 8
fi

# Ensures that the Continuous Integration is successful.
if [ -x "$(which hub)" ]; then
  readonly CI_STATUS="$(hub ci-status "${BRANCH}")"
  if [ "${CI_STATUS}" != "success" ]; then
    if [ "${FORCE_SUBMIT}" == "-f" ] || [ "${FORCE_SUBMIT}" == "--force" ]; then
      echo "WARNING: forcing submission despite CI status \"${CI_STATUS}\"."
    else
      echo "Continuous integration is \"${CI_STATUS}\", use \"-f\" to submit anyway:"
      hub ci-status -v "${BRANCH}"
      exit 11
    fi
  fi
fi

# Get latest code from remote.
git fetch

# The full name of the remote default branch, usually "origin/default_branch".
readonly BASE_BRANCH="${BASE_REMOTE}/${DEFAULT_REMOTE_BRANCH}"
# Git hash of the latest status of remote default branch.
readonly BASE_DEFAULT="$(git rev-parse "${BASE_BRANCH}")"
# Git hash of the current branch to submit.
readonly BRANCH_INITIAL="$(git rev-parse "${BRANCH}")"
# The name of the remote tracked by this branch, usually "origin".
readonly BRANCH_REMOTE="$(git config "branch.${BRANCH}.remote")"
# The name of the remote branch tracked by this one.
readonly BRANCH_MERGE="$(git config "branch.${BRANCH}.merge" | sed -e s/^refs\\/heads\\///)"

# Abort all changes and restore initial state before exiting.
function abort {
  echo "Something went wrong, aborting:" 1>&2

  echo "  Set default branch to ${BASE_DEFAULT}." 1>&2
  git checkout -f "${DEFAULT_BRANCH}"
  git reset --hard "${BASE_DEFAULT}"

  echo "  Set branch ${BRANCH} to ${BRANCH_INITIAL}." 1>&2
  git checkout -f "${BRANCH}"
  git reset --hard "${BRANCH_INITIAL}"

  exit 7
}

# Check that the changes are bundled as one commit on top of origin/default_branch.
while [ "${BASE_DEFAULT}" != "$(git rev-parse "${BRANCH}^")" ]; do
  if [ "${BASE_DEFAULT}" == "$(git rev-parse "${BRANCH}")" ]; then
    echo "No changes to submit."
    exit 3
  fi
  if ( git merge-base --is-ancestor "$(git rev-parse "${BRANCH}^")" "${BASE_DEFAULT}" ); then
    # There is only one new commit, but it's based on an old version of default branch.
    if [[ -n "${NO_SQUASH_ON_GITHUB}" ]] && ! (git rebase "${BASE_BRANCH}" "${BRANCH}"); then
      git rebase --abort
      exit 10
    fi
    break
  else
    echo "You should first group all your changes in one commit:" 1>&2
    echo "  git rebase -i ${BASE_BRANCH} ${BRANCH}" 1>&2
    if [[ -z "${NO_SQUASH_ON_GITHUB}" ]]; then
      exit 12
    fi
    read -p "Rebase now? [y/N]" answer
    if [ "${answer}" == "y" ] || [ "${answer}" == "Y" ]; then
      if ! (git rebase -i "${BASE_BRANCH}" "${BRANCH}"); then
        git rebase --abort
        exit 9
      fi
    else
      exit 4
    fi
  fi
done

# Check that the branch is tracking a remote branch.
if [ -z "${BRANCH_REMOTE}" ]; then
  echo "The branch ${BRANCH} is not tracked and has probably never been reviewed." 1>&2
  echo "  git push -u ${BASE_REMOTE} ${BRANCH}"
  read -p "Push now? [y/N]" answer
  if [ "${answer}" == "y" ] || [ "${answer}" == "Y" ]; then
    git push -u ${BASE_REMOTE} ${BRANCH} || abort
  fi
  exit 5
fi

if [ -z "${NO_SQUASH_ON_GITHUB}" ]; then

  if [ -z "${GITHUB_REPO_USER}" ]; then
    echo "Could not find the GitHub repository's name." 1>&2
    abort
  fi

  # Find pull-request ID.
  readonly PULL_REQUEST_NUMBER="$(hub pr show -h "$GITHUB_REPO_USER:$BRANCH_MERGE" -f %I)"
  if [[ -z "${PULL_REQUEST_NUMBER}" ]]; then
    echo "Could not find the Pull Request number." 1>&2
    abort
  fi

  # Ask GitHub to do the squash and merge!
  hub api -X PUT "/repos/{owner}/{repo}/pulls/${PULL_REQUEST_NUMBER}/merge" \
    -F merge_method=squash -F "sha=$BRANCH_INITIAL" || abort

  # Update default branch locally.
  git checkout $DEFAULT_BRANCH
  git pull --ff-only
else
  # Check that the remote branch is synced with the local one.
  if [ "$(git rev-parse "${BRANCH_REMOTE}/${BRANCH_MERGE}")" != "$(git rev-parse "${BRANCH}")" ]; then
    echo "Push your branch on ${BRANCH_REMOTE}, or you'll have a hard time removing the pull request:" 1>&2
    echo "  git push -f ${BRANCH_REMOTE} ${BRANCH}:${BRANCH_MERGE}"
    git push -f "${BRANCH_REMOTE}" "${BRANCH}:${BRANCH_MERGE}" || abort
  fi

  # Update default branch locally.
  git checkout $DEFAULT_BRANCH
  if ! (git rebase "${BRANCH}"); then
    git rebase --abort
    abort
  fi

  # Push updated default branch to remote.
  git push "${BASE_REMOTE}" ${DEFAULT_BRANCH} || abort
fi

# Remove branch locally and remotely.
if [[ "${BRANCH}" == "$(git rev-parse --abbrev-ref HEAD)" ]]; then
  git checkout $DEFAULT_BRANCH
fi
git branch -D "${BRANCH}"
if git show-branch "remotes/$BRANCH_REMOTE/$BRANCH_MERGE" > /dev/null; then
  git push -d ${BRANCH_REMOTE} "${BRANCH_MERGE}"
fi
