#!/bin/bash

# Parse the command line arguments.
POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"

case $key in
    -f|--force)
    readonly FORCE_PUSH="$1"
    shift # past argument
    ;;
    -u|--user)
    readonly USERNAME="$2"
    shift # past argument
    shift # past value
    ;;
    *)
    POSITIONAL+=("$1") # save it in an array for later
    shift # past argument
    ;;
esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters


readonly REVIEWER=$1
readonly REMOTE_REPO="origin"
if [ -z "$USERNAME" ]; then
    readonly USERNAME=$(git config user.email | sed -e "s/@.*$//")
fi

#Usually main (and previously master).
readonly DEFAULT_BRANCH="$(git rev-parse --abbrev-ref "${REMOTE_REPO}/HEAD" | cut -d/ -f2)"

readonly BRANCH="$(git rev-parse --abbrev-ref HEAD)"
if [ -z "${BRANCH}" ]; then
  exit 2
fi

if [ "${BRANCH}" == "${DEFAULT_BRANCH}" ]; then
  echo "branch required:" 1>&2
  git branch | grep -v \ $DEFAULT_BRANCH$ 1>&2
  exit 1
fi

# Ensures that current dir is clean.
if [ -n "$(git diff HEAD --shortstat 2> /dev/null | tail -n1)" ]; then
  echo "Current git status is dirty. Commit, stash or revert your changes before sending for review." 1>&2
  exit 3
fi

# Finds the best base branch.
if [ -n "$2" ]; then
  readonly REMOTE_BASE_BRANCH="$2"
else
  for sha1 in $(git rev-list --max-count=5 HEAD); do
    remote_branches="$(git branch -r --contains $sha1 --list "${REMOTE_REPO}/*")"
    if [ -n "$remote_branches" ]; then
      # Found at least one remote branch that contains this commit.
      break
    fi
  done
  if [ -z "$remote_branches" ]; then
    # Could not find a remote branch containing any of the 5 last commits :-(
    readonly REMOTE_BASE_BRANCH=DEFAULT_BRANCH
  else
    if grep "/${DEFAULT_BRANCH}\$" <<< "$remote_branches"; then
      # Just base the PR on default branch
      readonly REMOTE_BASE_BRANCH=DEFAULT_BRANCH
    else
      readonly REMOTE_BASE_BRANCH="$(head -n 1 <<< "$remote_branches" | sed -e "s/.*\///")"
      echo "Found a remote branch to base the PR on: $REMOTE_BASE_BRANCH"
    fi
  fi
fi
readonly BASE_BRANCH="$REMOTE_REPO/$REMOTE_BASE_BRANCH"

# Ensures that there are some change to review.
if [ -z "$(git diff $(git merge-base HEAD "${BASE_BRANCH}") --shortstat 2> /dev/null | tail -n1)" ]; then
  echo "All code on this branch has already been submitted" 1>&2
  exit 4
fi

# Ensures that there are no invalid characters (e.g. "#", "Ã©") in remote branch name.
function cleanup_branch_name {
  sed -e "s/#//g" <<< "$1" | iconv -f utf8 -t ascii//TRANSLIT
}

readonly EXISTING_REMOTE_BRANCH=$(git config "branch.${BRANCH}.merge" | sed -e "s/refs.heads.//")
if [ -n "${EXISTING_REMOTE_BRANCH}" ]  && [ "${EXISTING_REMOTE_BRANCH}" != "${DEFAULT_BRANCH}" ]; then
  readonly REMOTE_BRANCH="${EXISTING_REMOTE_BRANCH}"
else
  if [ -z "${USERNAME}" ]; then
    echo "Could not find username, most probably you need to setup an email with:" 1>&2
    echo "  git config user.email <me@bayesimpact.org>" 1>&2
    exit 5
  fi
  readonly REMOTE_BRANCH=$(cleanup_branch_name "${USERNAME}-${BRANCH}")
fi
git push ${FORCE_PUSH} -u "${REMOTE_REPO}" "${BRANCH}:${REMOTE_BRANCH}"

readonly MESSAGE_FILE=$(mktemp)

git log "${BASE_BRANCH}..${BRANCH}" --format=%B > "${MESSAGE_FILE}"

# Append message generated by .git-review-hook in repo.
# TODO: Test this feature.
readonly GIT_ROOT="$(git rev-parse --show-toplevel)"
readonly GIT_REVIEW_HOOK="${GIT_ROOT}/.git-review-hook"
if [ -x "${GIT_REVIEW_HOOK}" ]; then
  export BRANCH
  export REMOTE_BRANCH
  export REVIEWER
  "${GIT_REVIEW_HOOK}" >> "${MESSAGE_FILE}"
fi

if [ -z "${FORCE_PUSH}" ]; then
  readonly REMOTE_URL="$(git config --get remote.$REMOTE_REPO.url)"
  if [[ $REMOTE_URL == *"gitlab.com"* ]]; then
    # GitLab

    # Check if tool exists.
    if [ -z "$(which gitlab)" ] || ! [ -x $(which gitlab) ]; then
      echo "gitlab tool is not installed, please install it:" 1>&2
      echo "  https://github.com/bayesimpact/bayes-developer-setup/blob/${DEFAULT_BRANCH}/gitlab-cli.md" 1>&2
      exit 6
    fi
    # Find Project ID.
    GITLAB_PROJECT_NAME=${REMOTE_URL/git@gitlab.com:/}
    GITLAB_PROJECT_NAME=${GITLAB_PROJECT_NAME/.git/}
    readonly GITLAB_PROJECT_ID=$(gitlab project get --id "$GITLAB_PROJECT_NAME" | grep ^id: | cut -d ' ' -f 2)
    # Find reviewer ID.
    readonly GITLAB_REVIEWER_ID=$(gitlab user list --username "$REVIEWER" | grep ^id: | cut -d ' ' -f 2)
    # Create Merge Request.
    gitlab project-merge-request create --project-id "$GITLAB_PROJECT_ID" \
      --source-branch "$REMOTE_BRANCH" --target-branch "$REMOTE_BASE_BRANCH" \
      --assignee-id "$GITLAB_REVIEWER_ID" --title "$(head -n 1 $MESSAGE_FILE)"
  else
    # GitHub
    hub pull-request -F "${MESSAGE_FILE}" -a "${REVIEWER}" -r "${REVIEWER}" -h "${REMOTE_BRANCH}" -b "$REMOTE_BASE_BRANCH" | \
      sed -e "s/github.com/reviewable.io\/reviews/;s/pull\///"
  fi
fi

rm "${MESSAGE_FILE}"
